# Channels

-  Like a river , channel serves as conduit for a stream of information, values may be passed along the channel and then read out on the downstream.

- For this reason usually ``chan`` variables with the word ``Stream``.


## Unidirectional Channel

```go
    var dataStream chan interface{}

    dataStream = make(chan interface{})
```

## Read only channel

```go
var dataStream <- chan interface{}
dataStream = make(<- chan interface{})
```

## Write only channel

```go
var dataStream  chan <- interface{}
dataStream = make(chan <- interface{})
```

- We don't often see unidirectional channels instantiated , but we often see them used as ``func params`` and return types. Go will implicitly convert bidirection channels  to unidirectional when needed.

Example

```go
    var recieveChan <- chan interface{}
    var sendChan chan <- interface{}

    dataStream := make(chan interface{})
    
    // valid statements

    receiveChan  = dataStream
    sendChan = dataStream
```

- Channels in go are said to be ``blocking`` .

- This means any goroutine attempts to write to a channel that is full will wait until the channel has been emptied and any goroutine that attempts to read from a channel that is empty will wait until atleast once item is placed on it.

- We need to be careful on the deadlocks

```go
    stringStream := make(chan string)

    go func(){
        if 0 != 1 {
            return
        }
        stringStream <- "hi"
    }()

    fmt.Println(<-stringStream)
```

> fatal error : all goroutines are asleep - deadlock !

- The receiving from operator (<-) can also optionally return two values like

```go
func channelReturnsBoolValWhenReading() {
	fmt.Println("############## channelReturnsBoolValWhenReading ##############")
	stringStream := make(chan string)
	go func() {
		stringStream <- "Hello world" // Sending data to stream
	}()

	val, ok := <-stringStream
	fmt.Printf("(%v): %v\n", ok, val)
	fmt.Println("##############################")
}

```
- The second return value is a way for a read operation to indicate whether the read off the channel was a value generated by a write elsewhere in the process or a default value generated from a ``closed`` channel.

## Closed channel

- It is very useful to able to indicate that no more values will be  sent over a channel.

- This helps downstream processes know when to move on , exit , reopen communications on a new or different channel etc.

- To close a channel we use the ``close`` key word

```go
func readingFromClosedChan() {
	fmt.Println("############## readingFromClosedChan ##############")

	intStream := make(chan int)
	close(intStream)

	val, ok := <-intStream
	fmt.Printf("(%v): %v\n", ok, val) // falsy value of int will be returned , ok will be false
	fmt.Println("##############################")

}
```

## Ranging over a channel

- The ``range`` keyword used in conjuction with ``for`` statement supoorts channels as arguments and will automatically break the loop when channel is closed

- This allows concise iteration over range of values in a channel

```go
func rangingOverChannel() {
	intStream := make(chan int)

	go func() {
		defer close(intStream) // closing in defer is common pattern
		for i := 0; i < 10; i++ {
			intStream <- i
		}
	}()

	for val := range intStream {
		fmt.Println(val)
	}
}
```

- This loop doesnt return a exit criteria and the range does not return second boolean value.

## Signaling mechansim

- Closing  channel is also a mechanism to signal ``n`` goroutines waiting on a single channel instead of writing n times to a channel to unblock each goroutine

